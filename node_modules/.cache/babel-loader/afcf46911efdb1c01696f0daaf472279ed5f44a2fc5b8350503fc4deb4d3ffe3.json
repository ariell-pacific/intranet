{"ast":null,"code":"const {\n  createTransform\n} = require('redux-persist');\n\n/**\n * Transforms state on its way to being serialized and persisted\n * @param inboundState\n * @param config\n * @return {*}\n */\nconst transformPersistence = (inboundState, config) => {\n  inboundState = inboundState || {};\n\n  // If autoExpire is required i.e. user won't be setting the time\n  // then on each update change the `persistedAt` to be current time\n  // so that the rehydrater will pick it up based on this time if\n  // the record is not updated for some time\n  if (config.autoExpire && !inboundState[config.persistedAtKey]) {\n    inboundState = Object.assign({}, inboundState, {\n      [config.persistedAtKey]: new Date().getTime()\n    });\n  }\n  return inboundState;\n};\n\n/**\n * Transform state being rehydrated\n * @param outboundState\n * @param config\n * @return {*}\n */\nconst transformRehydrate = (outboundState, config) => {\n  outboundState = outboundState || {};\n\n  // Check for the possible expiry if state has the persisted date\n  if (config.expireSeconds && outboundState[config.persistedAtKey]) {\n    const startTime = new Date(outboundState[config.persistedAtKey]).getTime();\n    const endTime = new Date().getTime();\n    const duration = endTime - startTime;\n    const seconds = duration / 1000;\n\n    // If the state is older than the set expiry time,\n    // reset it to initial state\n    if (seconds > config.expireSeconds) {\n      return Object.assign({}, config.expiredState);\n    }\n  }\n  return outboundState;\n};\n\n/**\n * Creates transform object with the given expiry configuration\n * @param reducerKey\n * @param config\n * @return {Transform<{}, any>}\n */\nfunction expireReducer(reducerKey) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const defaults = {\n    // Key to be used for the time relative to which store is to be expired\n    persistedAtKey: '__persisted_at',\n    // Seconds after which store will be expired\n    expireSeconds: null,\n    // State to be used for resetting e.g. provide initial reducer state\n    expiredState: {},\n    // Use it if you don't want to manually set the time and want the store to\n    // be automatically expired if the record is not updated in the `expireSeconds` time\n    autoExpire: false\n  };\n  config = Object.assign({}, defaults, config);\n  return createTransform(\n  // transform state on its way to being serialized and persisted.\n  inboundState => transformPersistence(inboundState, config),\n  // transform state being rehydrated\n  outboundState => transformRehydrate(outboundState, config),\n  // define which reducers this transform gets called for.\n  {\n    whitelist: [reducerKey]\n  });\n}\nmodule.exports = expireReducer;","map":{"version":3,"names":["createTransform","require","transformPersistence","inboundState","config","autoExpire","persistedAtKey","Object","assign","Date","getTime","transformRehydrate","outboundState","expireSeconds","startTime","endTime","duration","seconds","expiredState","expireReducer","reducerKey","defaults","whitelist","module","exports"],"sources":["C:/Users/aao/Desktop/GoingUAT/node_modules/redux-persist-expire/index.js"],"sourcesContent":["const { createTransform } = require('redux-persist');\n\n/**\n * Transforms state on its way to being serialized and persisted\n * @param inboundState\n * @param config\n * @return {*}\n */\nconst transformPersistence = (inboundState, config) => {\n  inboundState = inboundState || {};\n\n  // If autoExpire is required i.e. user won't be setting the time\n  // then on each update change the `persistedAt` to be current time\n  // so that the rehydrater will pick it up based on this time if\n  // the record is not updated for some time\n  if (config.autoExpire && !inboundState[config.persistedAtKey]) {\n    inboundState = Object.assign({}, inboundState, {\n      [config.persistedAtKey]: (new Date()).getTime()\n    });\n  }\n\n  return inboundState;\n};\n\n/**\n * Transform state being rehydrated\n * @param outboundState\n * @param config\n * @return {*}\n */\nconst transformRehydrate = (outboundState, config) => {\n  outboundState = outboundState || {};\n\n  // Check for the possible expiry if state has the persisted date\n  if (config.expireSeconds && outboundState[config.persistedAtKey]) {\n    const startTime = (new Date(outboundState[config.persistedAtKey])).getTime();\n    const endTime = (new Date()).getTime();\n\n    const duration = endTime - startTime;\n    const seconds = duration / 1000;\n\n    // If the state is older than the set expiry time,\n    // reset it to initial state\n    if (seconds > config.expireSeconds) {\n      return Object.assign({}, config.expiredState);\n    }\n  }\n\n  return outboundState;\n};\n\n/**\n * Creates transform object with the given expiry configuration\n * @param reducerKey\n * @param config\n * @return {Transform<{}, any>}\n */\nfunction expireReducer(reducerKey, config = {}) {\n\n  const defaults = {\n    // Key to be used for the time relative to which store is to be expired\n    persistedAtKey: '__persisted_at',\n    // Seconds after which store will be expired\n    expireSeconds: null,\n    // State to be used for resetting e.g. provide initial reducer state\n    expiredState: {},\n    // Use it if you don't want to manually set the time and want the store to\n    // be automatically expired if the record is not updated in the `expireSeconds` time\n    autoExpire: false\n  };\n\n  config = Object.assign({}, defaults, config);\n\n  return createTransform(\n    // transform state on its way to being serialized and persisted.\n    (inboundState) => transformPersistence(inboundState, config),\n    // transform state being rehydrated\n    (outboundState) => transformRehydrate(outboundState, config),\n    // define which reducers this transform gets called for.\n    {\n      whitelist: [reducerKey]\n    }\n  );\n}\n\nmodule.exports = expireReducer;\n"],"mappings":"AAAA,MAAM;EAAEA;AAAgB,CAAC,GAAGC,OAAO,CAAC,eAAe,CAAC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,oBAAoB,GAAG,CAACC,YAAY,EAAEC,MAAM,KAAK;EACrDD,YAAY,GAAGA,YAAY,IAAI,CAAC,CAAC;;EAEjC;EACA;EACA;EACA;EACA,IAAIC,MAAM,CAACC,UAAU,IAAI,CAACF,YAAY,CAACC,MAAM,CAACE,cAAc,CAAC,EAAE;IAC7DH,YAAY,GAAGI,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEL,YAAY,EAAE;MAC7C,CAACC,MAAM,CAACE,cAAc,GAAI,IAAIG,IAAI,EAAE,CAAEC,OAAO;IAC/C,CAAC,CAAC;EACJ;EAEA,OAAOP,YAAY;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,kBAAkB,GAAG,CAACC,aAAa,EAAER,MAAM,KAAK;EACpDQ,aAAa,GAAGA,aAAa,IAAI,CAAC,CAAC;;EAEnC;EACA,IAAIR,MAAM,CAACS,aAAa,IAAID,aAAa,CAACR,MAAM,CAACE,cAAc,CAAC,EAAE;IAChE,MAAMQ,SAAS,GAAI,IAAIL,IAAI,CAACG,aAAa,CAACR,MAAM,CAACE,cAAc,CAAC,CAAC,CAAEI,OAAO,EAAE;IAC5E,MAAMK,OAAO,GAAI,IAAIN,IAAI,EAAE,CAAEC,OAAO,EAAE;IAEtC,MAAMM,QAAQ,GAAGD,OAAO,GAAGD,SAAS;IACpC,MAAMG,OAAO,GAAGD,QAAQ,GAAG,IAAI;;IAE/B;IACA;IACA,IAAIC,OAAO,GAAGb,MAAM,CAACS,aAAa,EAAE;MAClC,OAAON,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,MAAM,CAACc,YAAY,CAAC;IAC/C;EACF;EAEA,OAAON,aAAa;AACtB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,aAAa,CAACC,UAAU,EAAe;EAAA,IAAbhB,MAAM,uEAAG,CAAC,CAAC;EAE5C,MAAMiB,QAAQ,GAAG;IACf;IACAf,cAAc,EAAE,gBAAgB;IAChC;IACAO,aAAa,EAAE,IAAI;IACnB;IACAK,YAAY,EAAE,CAAC,CAAC;IAChB;IACA;IACAb,UAAU,EAAE;EACd,CAAC;EAEDD,MAAM,GAAGG,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEa,QAAQ,EAAEjB,MAAM,CAAC;EAE5C,OAAOJ,eAAe;EACpB;EACCG,YAAY,IAAKD,oBAAoB,CAACC,YAAY,EAAEC,MAAM,CAAC;EAC5D;EACCQ,aAAa,IAAKD,kBAAkB,CAACC,aAAa,EAAER,MAAM,CAAC;EAC5D;EACA;IACEkB,SAAS,EAAE,CAACF,UAAU;EACxB,CAAC,CACF;AACH;AAEAG,MAAM,CAACC,OAAO,GAAGL,aAAa"},"metadata":{},"sourceType":"script","externalDependencies":[]}